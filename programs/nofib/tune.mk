# Expected Targets: bitcode, optimize, link, run
#
#

# TODO: add a phony thing here


#LLVM_PATH=/Users/kavon/msr/llvm5/bin
LLVM_PATH=/Users/kavon/msr/tot-llvm/install/bin
GHC_ROOT=/Users/kavon/msr/alt-ghc
LOC=./out
PROGRAM=real/lift

# when comparing to clang -Ox, make sure this matches up so codegen is the same.
LLC_OPT=-O3

GHC=${GHC_ROOT}/inplace/bin/ghc-stage2
NOFIB_ROOT=${GHC_ROOT}/nofib
PROG_ROOT=${NOFIB_ROOT}/${PROGRAM}
MKFILE=${PROG_ROOT}/Makefile
RESOURCE=${LOC}/initial


# This target should build all initially unoptimized bitcode files
# and otherwise setup the directory for tuning.
# It is only executed once at the start of the tuning.
bitcode:
	pushd ${NOFIB_ROOT} ;\
	make boot ;\
	pushd ${PROGRAM} ;\
	make NoFibRuns=1 HC=${GHC} EXTRA_HC_OPTS="-fforce-recomp -fllvm -keep-llvm-files"
	${LLVM_PATH}/llvm-link ${NOFIB_ROOT}/${PROGRAM}/*.ll -o ${RESOURCE}.bc
	pushd ${NOFIB_ROOT}/${PROGRAM} ; make clean


# Target Inputs:
#   PASSES -- a string with the current pass configuration
#   ID     -- a configuration-unique ID number. Used to prevent file clashes
#             during parallel tuning.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success, and the time to execute this target
#   is recorded by the tuner.
#
#  This target should optimize all initial bitcode files according to
#  the PASSES given, and output the new bitcode files 
#  (using the unique ID in the filename for the configuration).
#  Run once per configuration.
#
optimize:
	${LLVM_PATH}/opt -stats -stats-json -info-output-file ${LOC}/stats_${ID}.json ${PASSES} -instcount ${RESOURCE}.bc -o ${RESOURCE}_${ID}.bc


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success.
#
#  This target should build the final executable. Run once per
#  configuration
link:
	echo "unable to link a nofib program at this time"
	false


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success. The time to execute this target is recorded.
#
#  This target should execute the final executable. 
#  Run possibly more than once per configuration.
run:
	${RESOURCE}_${ID}.bin


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Output the statistics collected from optimization to stdout as json data.
opt_stats:
	@touch ${LOC}/stats_${ID}.json  # if it's not there, we want cat to output a blank line
	@cat ${LOC}/stats_${ID}.json


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success.
#
#  This target should cleanup any temporary files generated by optimize/link
#  for this given ID.
selfclean:
	rm -f ${LOC}/*_${ID}.bc ${LOC}/*_${ID}.bin ${LOC}/*_${ID}.json ${LOC}/*_${ID}.s


# deletes _all_ temporary files. this executed only during startup (before bitcode)
clean:
	rm -f ${LOC}/*.bc ${LOC}/*.bin ${LOC}/*.ll ${LOC}/*.json ${LOC}/*.s
