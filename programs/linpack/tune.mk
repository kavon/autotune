# Expected Targets: bitcode, optimize, link, run
#
#

# TODO: add a phony thing here


LLVM_PATH=/Users/kavon/msr/llvm5/bin
#LLVM_PATH=/Users/kavon/msr/tot-llvm/install/bin

PROGRAM=linpack
EXT=.c

# relative to top of autotune dir
LOC=./programs/${PROGRAM}

RESOURCE=${LOC}/${PROGRAM}


# This target should build all initially unoptimized bitcode files
# and otherwise setup the directory for tuning.
# It is only executed once at the start of the tuning.
bitcode:
	${LLVM_PATH}/clang++ -O0 -S -emit-llvm -c ${RESOURCE}${EXT} -o ${RESOURCE}_orig.ll
	sed -f ${LOC}/../clang_clean.sed ${RESOURCE}_orig.ll > ${RESOURCE}.ll
	${LLVM_PATH}/opt -verify ${RESOURCE}.ll -o ${RESOURCE}.bc


# Target Inputs:
#   PASSES -- a string with the current pass configuration
#   ID     -- a configuration-unique ID number. Used to prevent file clashes
#             during parallel tuning.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success, and the time to execute this target
#   is recorded by the tuner.
#
#  This target should optimize all initial bitcode files according to
#  the PASSES given, and output the new bitcode files 
#  (using the unique ID in the filename for the configuration).
#  Run once per configuration.
#
optimize:
	${LLVM_PATH}/opt -stats -stats-json -info-output-file ${LOC}/stats_${ID}.json ${PASSES} ${RESOURCE}.bc -o ${RESOURCE}_${ID}.bc


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success.
#
#  This target should build the final executable. Run once per
#  configuration
link:
	${LLVM_PATH}/clang++ ${RESOURCE}_${ID}.bc -o ${RESOURCE}_${ID}.bin


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success. The time to execute this target is recorded.
#
#  This target should execute the final executable. 
#  Run possibly more than once per configuration.
run:
	${RESOURCE}_${ID}.bin


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Output the statistics collected from optimization to stdout as json data.
opt_stats:
	@touch ${LOC}/stats_${ID}.json  # if it's not there, we want cat to output a blank line
	@cat ${LOC}/stats_${ID}.json


# Target Inputs:
#   ID     -- a configuration-unique ID number.
#
# Target Outputs:
#   Any output to stdout/stderr is ignored. The return code is
#   checked for success.
#
#  This target should cleanup any temporary files generated by optimize/link
#  for this given ID.
selfclean:
	rm -f ${LOC}/*_${ID}.bc ${LOC}/*_${ID}.bin ${LOC}/*_${ID}.json


# deletes _all_ temporary files. this executed only during startup (before bitcode)
clean:
	rm -f ${LOC}/*.bc ${LOC}/*.bin ${LOC}/*.ll ${LOC}/*.json
